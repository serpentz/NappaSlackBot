{"version":3,"sources":["../src/http-handler.js"],"names":["verifyRequestSignature","createHTTPHandler","errorCodes","SIGNATURE_VERIFICATION_FAILURE","REQUEST_TIME_FAILURE","BODY_PARSER_NOT_PERMITTED","responseStatuses","OK","FAILURE","REDIRECT","NOT_FOUND","debug","signingSecret","requestSignature","requestTimestamp","body","fiveMinutesAgo","Math","floor","Date","now","error","Error","code","hmac","crypto","createHmac","split","version","hash","update","digest","adapter","poweredBy","sendResponse","res","_sendResponse","err","responseOptions","status","statusCode","failWithNoRetry","redirectLocation","setHeader","content","end","handleError","respond","message","waitForResponse","emit","process","env","NODE_ENV","userError","nextTick","slackEventRequestListener","req","method","url","rawBody","parseRawBody","Promise","resolve","then","r","toString","headers","JSON","parse","type","challenge","emitArguments","event","includeBody","push","includeHeaders","catch"],"mappings":"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","file":"http-handler.js","sourcesContent":["import debugFactory from 'debug';\nimport getRawBody from 'raw-body';\nimport crypto from 'crypto';\nimport timingSafeCompare from 'tsscmp';\nimport { packageIdentifier } from './util';\n\nexport const errorCodes = {\n  SIGNATURE_VERIFICATION_FAILURE: 'SLACKHTTPHANDLER_REQUEST_SIGNATURE_VERIFICATION_FAILURE',\n  REQUEST_TIME_FAILURE: 'SLACKHTTPHANDLER_REQUEST_TIMELIMIT_FAILURE',\n  BODY_PARSER_NOT_PERMITTED: 'SLACKADAPTER_BODY_PARSER_NOT_PERMITTED_FAILURE', // moved constant from adapter\n};\n\nconst responseStatuses = {\n  OK: 200,\n  FAILURE: 500,\n  REDIRECT: 302,\n  NOT_FOUND: 404,\n};\n\nconst debug = debugFactory('@slack/events-api:http-handler');\n\n/**\n * Method to verify signature of requests\n *\n * @param {string} signingSecret - Signing secret used to verify request signature\n * @param {string} requestSignature - Signature from request 'x-slack-signature' header\n * @param {number} requestTimestamp - Timestamp from request 'x-slack-request-timestamp' header\n * @param {string} body - Raw body string\n * @returns {boolean} Indicates if request is verified\n */\nexport function verifyRequestSignature({\n  signingSecret, requestSignature, requestTimestamp, body,\n}) {\n  // Divide current date to match Slack ts format\n  // Subtract 5 minutes from current time\n  const fiveMinutesAgo = Math.floor(Date.now() / 1000) - (60 * 5);\n\n  if (requestTimestamp < fiveMinutesAgo) {\n    debug('request is older than 5 minutes');\n    const error = new Error('Slack request signing verification outdated');\n    error.code = errorCodes.REQUEST_TIME_FAILURE;\n    throw error;\n  }\n\n  const hmac = crypto.createHmac('sha256', signingSecret);\n  const [version, hash] = requestSignature.split('=');\n  hmac.update(`${version}:${requestTimestamp}:${body}`);\n\n  if (!timingSafeCompare(hash, hmac.digest('hex'))) {\n    debug('request signature is not valid');\n    const error = new Error('Slack request signing verification failed');\n    error.code = errorCodes.SIGNATURE_VERIFICATION_FAILURE;\n    throw error;\n  }\n\n  debug('request signing verification success');\n  return true;\n}\n\nexport function createHTTPHandler(adapter) {\n  const poweredBy = packageIdentifier();\n\n  /**\n   * Binds a specific response instance to the function that works like a\n   * completion handler\n   *\n   * @param {Object} res - Response object\n   * @returns {Function} Returns a function used to send response\n   */\n  function sendResponse(res) {\n    // This function is the completion handler for sending a response to an event. It can either\n    // be invoked by automatically or by the user (when using the `waitForResponse` option).\n    return function _sendResponse(err, responseOptions) {\n      debug('sending response - error: %s, responseOptions: %o', err, responseOptions);\n      // Deal with errors up front\n      if (err) {\n        if (err.status) {\n          res.statusCode = err.status;\n        } else if (err.code === errorCodes.SIGNATURE_VERIFICATION_FAILURE ||\n            err.code === errorCodes.REQUEST_TIME_FAILURE) {\n          res.statusCode = responseStatuses.NOT_FOUND;\n        } else {\n          res.statusCode = responseStatuses.FAILURE;\n        }\n      } else {\n        // First determine the response status\n        if (responseOptions) {\n          if (responseOptions.failWithNoRetry) {\n            res.statusCode = responseStatuses.FAILURE;\n          } else if (responseOptions.redirectLocation) {\n            res.statusCode = responseStatuses.REDIRECT;\n          } else {\n            // URL Verification\n            res.statusCode = responseStatuses.OK;\n          }\n        } else {\n          res.statusCode = responseStatuses.OK;\n        }\n\n        // Next determine the response headers\n        if (responseOptions && responseOptions.failWithNoRetry) {\n          res.setHeader('X-Slack-No-Retry', '1');\n        }\n        res.setHeader('X-Slack-Powered-By', poweredBy);\n      }\n\n      // Lastly, send the response\n      if (responseOptions && responseOptions.content) {\n        res.end(responseOptions.content);\n      } else {\n        res.end();\n      }\n    };\n  }\n\n  /**\n   * Abstracts error handling.\n   *\n   * @param {Error} error\n   * @param {Function} respond\n   */\n  function handleError(error, respond) {\n    debug('handling error - message: %s, code: %s', error.message, error.code);\n    try {\n      if (adapter.waitForResponse) {\n        adapter.emit('error', error, respond);\n      } else if (process.env.NODE_ENV === 'development') {\n        adapter.emit('error', error);\n        respond({ status: 500 }, { content: error.message });\n      } else {\n        adapter.emit('error', error);\n        respond(error);\n      }\n    } catch (userError) {\n      process.nextTick(() => { throw userError; });\n    }\n  }\n\n  /**\n   * Request listener used to handle Slack requests and send responses and\n   * verify request signatures\n   *\n   * @param {Object} req - Request object\n   * @param {Object} res - Response object\n   */\n  return function slackEventRequestListener(req, res) {\n    debug('request recieved - method: %s, path: %s', req.method, req.url);\n\n    // Bind a response function to this request's respond object.\n    const respond = sendResponse(res);\n\n    // If parser is being used and we don't receive the raw payload via `rawBody`,\n    // we can't verify request signature\n    if (req.body && !req.rawBody) {\n      const error = new Error('Parsing request body prohibits request signature verification');\n      error.code = errorCodes.BODY_PARSER_NOT_PERMITTED;\n      handleError(error, respond);\n      return;\n    }\n\n    // Some serverless cloud providers (e.g. Google Firebase Cloud Functions) might populate\n    // the request with a bodyparser before it can be populated by the SDK.\n    // To prevent throwing an error here, we check the `rawBody` field before parsing the request\n    // through the `raw-body` module (see Issue #85 - https://github.com/slackapi/node-slack-events-api/issues/85)\n    let parseRawBody;\n    if (req.rawBody) {\n      debug('Parsing request with a rawBody attribute');\n      parseRawBody = new Promise((resolve) => {\n        resolve(req.rawBody);\n      });\n    } else {\n      debug('Parsing raw request');\n      parseRawBody = getRawBody(req);\n    }\n\n    parseRawBody\n      .then((r) => {\n        const rawBody = r.toString();\n        if (verifyRequestSignature({\n          signingSecret: adapter.signingSecret,\n          requestSignature: req.headers['x-slack-signature'],\n          requestTimestamp: req.headers['x-slack-request-timestamp'],\n          body: rawBody,\n        })) {\n          // Request signature is verified\n          // Parse raw body\n          const body = JSON.parse(rawBody);\n\n          // Handle URL verification challenge\n          if (body.type === 'url_verification') {\n            debug('handling url verification');\n            respond(null, { content: body.challenge });\n            return;\n          }\n\n          const emitArguments = [body.event];\n          if (adapter.includeBody) {\n            emitArguments.push(body);\n          }\n          if (adapter.includeHeaders) {\n            emitArguments.push(req.headers);\n          }\n          if (adapter.waitForResponse) {\n            emitArguments.push(respond);\n          } else {\n            respond();\n          }\n\n          debug('emitting event -  type: %s, arguments: %o', body.event.type, emitArguments);\n          adapter.emit(body.event.type, ...emitArguments);\n        }\n      }).catch((error) => {\n        handleError(error, respond);\n      });\n  };\n}\n"]}