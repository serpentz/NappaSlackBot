'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.errorCodes = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.verifyRequestSignature = verifyRequestSignature;
exports.createHTTPHandler = createHTTPHandler;

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _rawBody = require('raw-body');

var _rawBody2 = _interopRequireDefault(_rawBody);

var _crypto = require('crypto');

var _crypto2 = _interopRequireDefault(_crypto);

var _tsscmp = require('tsscmp');

var _tsscmp2 = _interopRequireDefault(_tsscmp);

var _util = require('./util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var errorCodes = exports.errorCodes = {
  SIGNATURE_VERIFICATION_FAILURE: 'SLACKHTTPHANDLER_REQUEST_SIGNATURE_VERIFICATION_FAILURE',
  REQUEST_TIME_FAILURE: 'SLACKHTTPHANDLER_REQUEST_TIMELIMIT_FAILURE',
  BODY_PARSER_NOT_PERMITTED: 'SLACKADAPTER_BODY_PARSER_NOT_PERMITTED_FAILURE' // moved constant from adapter
};

var responseStatuses = {
  OK: 200,
  FAILURE: 500,
  REDIRECT: 302,
  NOT_FOUND: 404
};

var debug = (0, _debug2.default)('@slack/events-api:http-handler');

/**
 * Method to verify signature of requests
 *
 * @param {string} signingSecret - Signing secret used to verify request signature
 * @param {string} requestSignature - Signature from request 'x-slack-signature' header
 * @param {number} requestTimestamp - Timestamp from request 'x-slack-request-timestamp' header
 * @param {string} body - Raw body string
 * @returns {boolean} Indicates if request is verified
 */
function verifyRequestSignature(_ref) {
  var signingSecret = _ref.signingSecret,
      requestSignature = _ref.requestSignature,
      requestTimestamp = _ref.requestTimestamp,
      body = _ref.body;

  // Divide current date to match Slack ts format
  // Subtract 5 minutes from current time
  var fiveMinutesAgo = Math.floor(Date.now() / 1000) - 60 * 5;

  if (requestTimestamp < fiveMinutesAgo) {
    debug('request is older than 5 minutes');
    var error = new Error('Slack request signing verification outdated');
    error.code = errorCodes.REQUEST_TIME_FAILURE;
    throw error;
  }

  var hmac = _crypto2.default.createHmac('sha256', signingSecret);

  var _requestSignature$spl = requestSignature.split('='),
      _requestSignature$spl2 = _slicedToArray(_requestSignature$spl, 2),
      version = _requestSignature$spl2[0],
      hash = _requestSignature$spl2[1];

  hmac.update(version + ':' + requestTimestamp + ':' + body);

  if (!(0, _tsscmp2.default)(hash, hmac.digest('hex'))) {
    debug('request signature is not valid');
    var _error = new Error('Slack request signing verification failed');
    _error.code = errorCodes.SIGNATURE_VERIFICATION_FAILURE;
    throw _error;
  }

  debug('request signing verification success');
  return true;
}

function createHTTPHandler(adapter) {
  var poweredBy = (0, _util.packageIdentifier)();

  /**
   * Binds a specific response instance to the function that works like a
   * completion handler
   *
   * @param {Object} res - Response object
   * @returns {Function} Returns a function used to send response
   */
  function sendResponse(res) {
    // This function is the completion handler for sending a response to an event. It can either
    // be invoked by automatically or by the user (when using the `waitForResponse` option).
    return function _sendResponse(err, responseOptions) {
      debug('sending response - error: %s, responseOptions: %o', err, responseOptions);
      // Deal with errors up front
      if (err) {
        if (err.status) {
          res.statusCode = err.status;
        } else if (err.code === errorCodes.SIGNATURE_VERIFICATION_FAILURE || err.code === errorCodes.REQUEST_TIME_FAILURE) {
          res.statusCode = responseStatuses.NOT_FOUND;
        } else {
          res.statusCode = responseStatuses.FAILURE;
        }
      } else {
        // First determine the response status
        if (responseOptions) {
          if (responseOptions.failWithNoRetry) {
            res.statusCode = responseStatuses.FAILURE;
          } else if (responseOptions.redirectLocation) {
            res.statusCode = responseStatuses.REDIRECT;
          } else {
            // URL Verification
            res.statusCode = responseStatuses.OK;
          }
        } else {
          res.statusCode = responseStatuses.OK;
        }

        // Next determine the response headers
        if (responseOptions && responseOptions.failWithNoRetry) {
          res.setHeader('X-Slack-No-Retry', '1');
        }
        res.setHeader('X-Slack-Powered-By', poweredBy);
      }

      // Lastly, send the response
      if (responseOptions && responseOptions.content) {
        res.end(responseOptions.content);
      } else {
        res.end();
      }
    };
  }

  /**
   * Abstracts error handling.
   *
   * @param {Error} error
   * @param {Function} respond
   */
  function handleError(error, respond) {
    debug('handling error - message: %s, code: %s', error.message, error.code);
    try {
      if (adapter.waitForResponse) {
        adapter.emit('error', error, respond);
      } else if (process.env.NODE_ENV === 'development') {
        adapter.emit('error', error);
        respond({ status: 500 }, { content: error.message });
      } else {
        adapter.emit('error', error);
        respond(error);
      }
    } catch (userError) {
      process.nextTick(function () {
        throw userError;
      });
    }
  }

  /**
   * Request listener used to handle Slack requests and send responses and
   * verify request signatures
   *
   * @param {Object} req - Request object
   * @param {Object} res - Response object
   */
  return function slackEventRequestListener(req, res) {
    debug('request recieved - method: %s, path: %s', req.method, req.url);

    // Bind a response function to this request's respond object.
    var respond = sendResponse(res);

    // If parser is being used and we don't receive the raw payload via `rawBody`,
    // we can't verify request signature
    if (req.body && !req.rawBody) {
      var error = new Error('Parsing request body prohibits request signature verification');
      error.code = errorCodes.BODY_PARSER_NOT_PERMITTED;
      handleError(error, respond);
      return;
    }

    // Some serverless cloud providers (e.g. Google Firebase Cloud Functions) might populate
    // the request with a bodyparser before it can be populated by the SDK.
    // To prevent throwing an error here, we check the `rawBody` field before parsing the request
    // through the `raw-body` module (see Issue #85 - https://github.com/slackapi/node-slack-events-api/issues/85)
    var parseRawBody = void 0;
    if (req.rawBody) {
      debug('Parsing request with a rawBody attribute');
      parseRawBody = new Promise(function (resolve) {
        resolve(req.rawBody);
      });
    } else {
      debug('Parsing raw request');
      parseRawBody = (0, _rawBody2.default)(req);
    }

    parseRawBody.then(function (r) {
      var rawBody = r.toString();
      if (verifyRequestSignature({
        signingSecret: adapter.signingSecret,
        requestSignature: req.headers['x-slack-signature'],
        requestTimestamp: req.headers['x-slack-request-timestamp'],
        body: rawBody
      })) {
        // Request signature is verified
        // Parse raw body
        var body = JSON.parse(rawBody);

        // Handle URL verification challenge
        if (body.type === 'url_verification') {
          debug('handling url verification');
          respond(null, { content: body.challenge });
          return;
        }

        var emitArguments = [body.event];
        if (adapter.includeBody) {
          emitArguments.push(body);
        }
        if (adapter.includeHeaders) {
          emitArguments.push(req.headers);
        }
        if (adapter.waitForResponse) {
          emitArguments.push(respond);
        } else {
          respond();
        }

        debug('emitting event -  type: %s, arguments: %o', body.event.type, emitArguments);
        adapter.emit.apply(adapter, [body.event.type].concat(emitArguments));
      }
    }).catch(function (error) {
      handleError(error, respond);
    });
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9odHRwLWhhbmRsZXIuanMiXSwibmFtZXMiOlsidmVyaWZ5UmVxdWVzdFNpZ25hdHVyZSIsImNyZWF0ZUhUVFBIYW5kbGVyIiwiZXJyb3JDb2RlcyIsIlNJR05BVFVSRV9WRVJJRklDQVRJT05fRkFJTFVSRSIsIlJFUVVFU1RfVElNRV9GQUlMVVJFIiwiQk9EWV9QQVJTRVJfTk9UX1BFUk1JVFRFRCIsInJlc3BvbnNlU3RhdHVzZXMiLCJPSyIsIkZBSUxVUkUiLCJSRURJUkVDVCIsIk5PVF9GT1VORCIsImRlYnVnIiwic2lnbmluZ1NlY3JldCIsInJlcXVlc3RTaWduYXR1cmUiLCJyZXF1ZXN0VGltZXN0YW1wIiwiYm9keSIsImZpdmVNaW51dGVzQWdvIiwiTWF0aCIsImZsb29yIiwiRGF0ZSIsIm5vdyIsImVycm9yIiwiRXJyb3IiLCJjb2RlIiwiaG1hYyIsImNyeXB0byIsImNyZWF0ZUhtYWMiLCJzcGxpdCIsInZlcnNpb24iLCJoYXNoIiwidXBkYXRlIiwiZGlnZXN0IiwiYWRhcHRlciIsInBvd2VyZWRCeSIsInNlbmRSZXNwb25zZSIsInJlcyIsIl9zZW5kUmVzcG9uc2UiLCJlcnIiLCJyZXNwb25zZU9wdGlvbnMiLCJzdGF0dXMiLCJzdGF0dXNDb2RlIiwiZmFpbFdpdGhOb1JldHJ5IiwicmVkaXJlY3RMb2NhdGlvbiIsInNldEhlYWRlciIsImNvbnRlbnQiLCJlbmQiLCJoYW5kbGVFcnJvciIsInJlc3BvbmQiLCJtZXNzYWdlIiwid2FpdEZvclJlc3BvbnNlIiwiZW1pdCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsInVzZXJFcnJvciIsIm5leHRUaWNrIiwic2xhY2tFdmVudFJlcXVlc3RMaXN0ZW5lciIsInJlcSIsIm1ldGhvZCIsInVybCIsInJhd0JvZHkiLCJwYXJzZVJhd0JvZHkiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJyIiwidG9TdHJpbmciLCJoZWFkZXJzIiwiSlNPTiIsInBhcnNlIiwidHlwZSIsImNoYWxsZW5nZSIsImVtaXRBcmd1bWVudHMiLCJldmVudCIsImluY2x1ZGVCb2R5IiwicHVzaCIsImluY2x1ZGVIZWFkZXJzIiwiY2F0Y2giXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztRQThCZ0JBLHNCLEdBQUFBLHNCO1FBNkJBQyxpQixHQUFBQSxpQjs7QUEzRGhCOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFTyxJQUFNQyxrQ0FBYTtBQUN4QkMsa0NBQWdDLHlEQURSO0FBRXhCQyx3QkFBc0IsNENBRkU7QUFHeEJDLDZCQUEyQixnREFISCxDQUdxRDtBQUhyRCxDQUFuQjs7QUFNUCxJQUFNQyxtQkFBbUI7QUFDdkJDLE1BQUksR0FEbUI7QUFFdkJDLFdBQVMsR0FGYztBQUd2QkMsWUFBVSxHQUhhO0FBSXZCQyxhQUFXO0FBSlksQ0FBekI7O0FBT0EsSUFBTUMsUUFBUSxxQkFBYSxnQ0FBYixDQUFkOztBQUVBOzs7Ozs7Ozs7QUFTTyxTQUFTWCxzQkFBVCxPQUVKO0FBQUEsTUFERFksYUFDQyxRQUREQSxhQUNDO0FBQUEsTUFEY0MsZ0JBQ2QsUUFEY0EsZ0JBQ2Q7QUFBQSxNQURnQ0MsZ0JBQ2hDLFFBRGdDQSxnQkFDaEM7QUFBQSxNQURrREMsSUFDbEQsUUFEa0RBLElBQ2xEOztBQUNEO0FBQ0E7QUFDQSxNQUFNQyxpQkFBaUJDLEtBQUtDLEtBQUwsQ0FBV0MsS0FBS0MsR0FBTCxLQUFhLElBQXhCLElBQWlDLEtBQUssQ0FBN0Q7O0FBRUEsTUFBSU4sbUJBQW1CRSxjQUF2QixFQUF1QztBQUNyQ0wsVUFBTSxpQ0FBTjtBQUNBLFFBQU1VLFFBQVEsSUFBSUMsS0FBSixDQUFVLDZDQUFWLENBQWQ7QUFDQUQsVUFBTUUsSUFBTixHQUFhckIsV0FBV0Usb0JBQXhCO0FBQ0EsVUFBTWlCLEtBQU47QUFDRDs7QUFFRCxNQUFNRyxPQUFPQyxpQkFBT0MsVUFBUCxDQUFrQixRQUFsQixFQUE0QmQsYUFBNUIsQ0FBYjs7QUFaQyw4QkFhdUJDLGlCQUFpQmMsS0FBakIsQ0FBdUIsR0FBdkIsQ0Fi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ZW50IjpbImltcG9ydCBkZWJ1Z0ZhY3RvcnkgZnJvbSAnZGVidWcnO1xuaW1wb3J0IGdldFJhd0JvZHkgZnJvbSAncmF3LWJvZHknO1xuaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHRpbWluZ1NhZmVDb21wYXJlIGZyb20gJ3Rzc2NtcCc7XG5pbXBvcnQgeyBwYWNrYWdlSWRlbnRpZmllciB9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBjb25zdCBlcnJvckNvZGVzID0ge1xuICBTSUdOQVRVUkVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkU6ICdTTEFDS0hUVFBIQU5ETEVSX1JFUVVFU1RfU0lHTkFUVVJFX1ZFUklGSUNBVElPTl9GQUlMVVJFJyxcbiAgUkVRVUVTVF9USU1FX0ZBSUxVUkU6ICdTTEFDS0hUVFBIQU5ETEVSX1JFUVVFU1RfVElNRUxJTUlUX0ZBSUxVUkUnLFxuICBCT0RZX1BBUlNFUl9OT1RfUEVSTUlUVEVEOiAnU0xBQ0tBREFQVEVSX0JPRFlfUEFSU0VSX05PVF9QRVJNSVRURURfRkFJTFVSRScsIC8vIG1vdmVkIGNvbnN0YW50IGZyb20gYWRhcHRlclxufTtcblxuY29uc3QgcmVzcG9uc2VTdGF0dXNlcyA9IHtcbiAgT0s6IDIwMCxcbiAgRkFJTFVSRTogNTAwLFxuICBSRURJUkVDVDogMzAyLFxuICBOT1RfRk9VTkQ6IDQwNCxcbn07XG5cbmNvbnN0IGRlYnVnID0gZGVidWdGYWN0b3J5KCdAc2xhY2svZXZlbnRzLWFwaTpodHRwLWhhbmRsZXInKTtcblxuLyoqXG4gKiBNZXRob2QgdG8gdmVyaWZ5IHNpZ25hdHVyZSBvZiByZXF1ZXN0c1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaWduaW5nU2VjcmV0IC0gU2lnbmluZyBzZWNyZXQgdXNlZCB0byB2ZXJpZnkgcmVxdWVzdCBzaWduYXR1cmVcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0U2lnbmF0dXJlIC0gU2lnbmF0dXJlIGZyb20gcmVxdWVzdCAneC1zbGFjay1zaWduYXR1cmUnIGhlYWRlclxuICogQHBhcmFtIHtudW1iZXJ9IHJlcXVlc3RUaW1lc3RhbXAgLSBUaW1lc3RhbXAgZnJvbSByZXF1ZXN0ICd4LXNsYWNrLXJlcXVlc3QtdGltZXN0YW1wJyBoZWFkZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBib2R5IC0gUmF3IGJvZHkgc3RyaW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSW5kaWNhdGVzIGlmIHJlcXVlc3QgaXMgdmVyaWZpZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVJlcXVlc3RTaWduYXR1cmUoe1xuICBzaWduaW5nU2VjcmV0LCByZXF1ZXN0U2lnbmF0dXJlLCByZXF1ZXN0VGltZXN0YW1wLCBib2R5LFxufSkge1xuICAvLyBEaXZpZGUgY3VycmVudCBkYXRlIHRvIG1hdGNoIFNsYWNrIHRzIGZvcm1hdFxuICAvLyBTdWJ0cmFjdCA1IG1pbnV0ZXMgZnJvbSBjdXJyZW50IHRpbWVcbiAgY29uc3QgZml2ZU1pbnV0ZXNBZ28gPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSAtICg2MCAqIDUpO1xuXG4gIGlmIChyZXF1ZXN0VGltZXN0YW1wIDwgZml2ZU1pbnV0ZXNBZ28pIHtcbiAgICBkZWJ1ZygncmVxdWVzdCBpcyBvbGRlciB0aGFuIDUgbWludXRlcycpO1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdTbGFjayByZXF1ZXN0IHNpZ25pbmcgdmVyaWZpY2F0aW9uIG91dGRhdGVkJyk7XG4gICAgZXJyb3IuY29kZSA9IGVycm9yQ29kZXMuUkVRVUVTVF9USU1FX0ZBSUxVUkU7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICBjb25zdCBobWFjID0gY3J5cHRvLmNyZWF0ZUhtYWMoJ3NoYTI1NicsIHNpZ25pbmdTZWNyZXQpO1xuICBjb25zdCBbdmVyc2lvbiwgaGFzaF0gPSByZXF1ZXN0U2lnbmF0dXJlLnNwbGl0KCc9Jyk7XG4gIGhtYWMudXBkYXRlKGAke3ZlcnNpb259OiR7cmVxdWVzdFRpbWVzdGFtcH06JHtib2R5fWApO1xuXG4gIGlmICghdGltaW5nU2FmZUNvbXBhcmUoaGFzaCwgaG1hYy5kaWdlc3QoJ2hleCcpKSkge1xuICAgIGRlYnVnKCdyZXF1ZXN0IHNpZ25hdHVyZSBpcyBub3QgdmFsaWQnKTtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignU2xhY2sgcmVxdWVzdCBzaWduaW5nIHZlcmlmaWNhdGlvbiBmYWlsZWQnKTtcbiAgICBlcnJvci5jb2RlID0gZXJyb3JDb2Rlcy5TSUdOQVRVUkVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkU7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICBkZWJ1ZygncmVxdWVzdCBzaWduaW5nIHZlcmlmaWNhdGlvbiBzdWNjZXNzJyk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSFRUUEhhbmRsZXIoYWRhcHRlcikge1xuICBjb25zdCBwb3dlcmVkQnkgPSBwYWNrYWdlSWRlbnRpZmllcigpO1xuXG4gIC8qKlxuICAgKiBCaW5kcyBhIHNwZWNpZmljIHJlc3BvbnNlIGluc3RhbmNlIHRvIHRoZSBmdW5jdGlvbiB0aGF0IHdvcmtzIGxpa2UgYVxuICAgKiBjb21wbGV0aW9uIGhhbmRsZXJcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlcyAtIFJlc3BvbnNlIG9iamVjdFxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBmdW5jdGlvbiB1c2VkIHRvIHNlbmQgcmVzcG9uc2VcbiAgICovXG4gIGZ1bmN0aW9uIHNlbmRSZXNwb25zZShyZXMpIHtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHRoZSBjb21wbGV0aW9uIGhhbmRsZXIgZm9yIHNlbmRpbmcgYSByZXNwb25zZSB0byBhbiBldmVudC4gSXQgY2FuIGVpdGhlclxuICAgIC8vIGJlIGludm9rZWQgYnkgYXV0b21hdGljYWxseSBvciBieSB0aGUgdXNlciAod2hlbiB1c2luZyB0aGUgYHdhaXRGb3JSZXNwb25zZWAgb3B0aW9uKS5cbiAgICByZXR1cm4gZnVuY3Rpb24gX3NlbmRSZXNwb25zZShlcnIsIHJlc3BvbnNlT3B0aW9ucykge1xuICAgICAgZGVidWcoJ3NlbmRpbmcgcmVzcG9uc2UgLSBlcnJvcjogJXMsIHJlc3BvbnNlT3B0aW9uczogJW8nLCBlcnIsIHJlc3BvbnNlT3B0aW9ucyk7XG4gICAgICAvLyBEZWFsIHdpdGggZXJyb3JzIHVwIGZyb250XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIuc3RhdHVzKSB7XG4gICAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSBlcnIuc3RhdHVzO1xuICAgICAgICB9IGVsc2UgaWYgKGVyci5jb2RlID09PSBlcnJvckNvZGVzLlNJR05BVFVSRV9WRVJJRklDQVRJT05fRkFJTFVSRSB8fFxuICAgICAgICAgICAgZXJyLmNvZGUgPT09IGVycm9yQ29kZXMuUkVRVUVTVF9USU1FX0ZBSUxVUkUpIHtcbiAgICAgICAgICByZXMuc3RhdHVzQ29kZSA9IHJlc3BvbnNlU3RhdHVzZXMuTk9UX0ZPVU5EO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcy5zdGF0dXNDb2RlID0gcmVzcG9uc2VTdGF0dXNlcy5GQUlMVVJFO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGaXJzdCBkZXRlcm1pbmUgdGhlIHJlc3BvbnNlIHN0YXR1c1xuICAgICAgICBpZiAocmVzcG9uc2VPcHRpb25zKSB7XG4gICAgICAgICAgaWYgKHJlc3BvbnNlT3B0aW9ucy5mYWlsV2l0aE5vUmV0cnkpIHtcbiAgICAgICAgICAgIHJlcy5zdGF0dXNDb2RlID0gcmVzcG9uc2VTdGF0dXNlcy5GQUlMVVJFO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2VPcHRpb25zLnJlZGlyZWN0TG9jYXRpb24pIHtcbiAgICAgICAgICAgIHJlcy5zdGF0dXNDb2RlID0gcmVzcG9uc2VTdGF0dXNlcy5SRURJUkVDVDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVVJMIFZlcmlmaWNhdGlvblxuICAgICAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSByZXNwb25zZVN0YXR1c2VzLk9LO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXMuc3RhdHVzQ29kZSA9IHJlc3BvbnNlU3RhdHVzZXMuT0s7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOZXh0IGRldGVybWluZSB0aGUgcmVzcG9uc2UgaGVhZGVyc1xuICAgICAgICBpZiAocmVzcG9uc2VPcHRpb25zICYmIHJlc3BvbnNlT3B0aW9ucy5mYWlsV2l0aE5vUmV0cnkpIHtcbiAgICAgICAgICByZXMuc2V0SGVhZGVyKCdYLVNsYWNrLU5vLVJldHJ5JywgJzEnKTtcbiAgICAgICAgfVxuICAgICAgICByZXMuc2V0SGVhZGVyKCdYLVNsYWNrLVBvd2VyZWQtQnknLCBwb3dlcmVkQnkpO1xuICAgICAgfVxuXG4gICAgICAvLyBMYXN0bHksIHNlbmQgdGhlIHJlc3BvbnNlXG4gICAgICBpZiAocmVzcG9uc2VPcHRpb25zICYmIHJlc3BvbnNlT3B0aW9ucy5jb250ZW50KSB7XG4gICAgICAgIHJlcy5lbmQocmVzcG9uc2VPcHRpb25zLmNvbnRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQWJzdHJhY3RzIGVycm9yIGhhbmRsaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJvclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNwb25kXG4gICAqL1xuICBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvciwgcmVzcG9uZCkge1xuICAgIGRlYnVnKCdoYW5kbGluZyBlcnJvciAtIG1lc3NhZ2U6ICVzLCBjb2RlOiAlcycsIGVycm9yLm1lc3NhZ2UsIGVycm9yLmNvZGUpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoYWRhcHRlci53YWl0Rm9yUmVzcG9uc2UpIHtcbiAgICAgICAgYWRhcHRlci5lbWl0KCdlcnJvcicsIGVycm9yLCByZXNwb25kKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgYWRhcHRlci5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgcmVzcG9uZCh7IHN0YXR1czogNTAwIH0sIHsgY29udGVudDogZXJyb3IubWVzc2FnZSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkYXB0ZXIuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgIHJlc3BvbmQoZXJyb3IpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKHVzZXJFcnJvcikge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7IHRocm93IHVzZXJFcnJvcjsgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgbGlzdGVuZXIgdXNlZCB0byBoYW5kbGUgU2xhY2sgcmVxdWVzdHMgYW5kIHNlbmQgcmVzcG9uc2VzIGFuZFxuICAgKiB2ZXJpZnkgcmVxdWVzdCBzaWduYXR1cmVzXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXEgLSBSZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzIC0gUmVzcG9uc2Ugb2JqZWN0XG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24gc2xhY2tFdmVudFJlcXVlc3RMaXN0ZW5lcihyZXEsIHJlcykge1xuICAgIGRlYnVnKCdyZXF1ZXN0IHJlY2lldmVkIC0gbWV0aG9kOiAlcywgcGF0aDogJXMnLCByZXEubWV0aG9kLCByZXEudXJsKTtcblxuICAgIC8vIEJpbmQgYSByZXNwb25zZSBmdW5jdGlvbiB0byB0aGlzIHJlcXVlc3QncyByZXNwb25kIG9iamVjdC5cbiAgICBjb25zdCByZXNwb25kID0gc2VuZFJlc3BvbnNlKHJlcyk7XG5cbiAgICAvLyBJZiBwYXJzZXIgaXMgYmVpbmcgdXNlZCBhbmQgd2UgZG9uJ3QgcmVjZWl2ZSB0aGUgcmF3IHBheWxvYWQgdmlhIGByYXdCb2R5YCxcbiAgICAvLyB3ZSBjYW4ndCB2ZXJpZnkgcmVxdWVzdCBzaWduYXR1cmVcbiAgICBpZiAocmVxLmJvZHkgJiYgIXJlcS5yYXdCb2R5KSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignUGFyc2luZyByZXF1ZXN0IGJvZHkgcHJvaGliaXRzIHJlcXVlc3Qgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbicpO1xuICAgICAgZXJyb3IuY29kZSA9IGVycm9yQ29kZXMuQk9EWV9QQVJTRVJfTk9UX1BFUk1JVFRFRDtcbiAgICAgIGhhbmRsZUVycm9yKGVycm9yLCByZXNwb25kKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTb21lIHNlcnZlcmxlc3MgY2xvdWQgcHJvdmlkZXJzIChlLmcuIEdvb2dsZSBGaXJlYmFzZSBDbG91ZCBGdW5jdGlvbnMpIG1pZ2h0IHBvcHVsYXRlXG4gICAgLy8gdGhlIHJlcXVlc3Qgd2l0aCBhIGJvZHlwYXJzZXIgYmVmb3JlIGl0IGNhbiBiZSBwb3B1bGF0ZWQgYnkgdGhlIFNESy5cbiAgICAvLyBUbyBwcmV2ZW50IHRocm93aW5nIGFuIGVycm9yIGhlcmUsIHdlIGNoZWNrIHRoZSBgcmF3Qm9keWAgZmllbGQgYmVmb3JlIHBhcnNpbmcgdGhlIHJlcXVlc3RcbiAgICAvLyB0aHJvdWdoIHRoZSBgcmF3LWJvZHlgIG1vZHVsZSAoc2VlIElzc3VlICM4NSAtIGh0dHBzOi8vZ2l0aHViLmNvbS9zbGFja2FwaS9ub2RlLXNsYWNrLWV2ZW50cy1hcGkvaXNzdWVzLzg1KVxuICAgIGxldCBwYXJzZVJhd0JvZHk7XG4gICAgaWYgKHJlcS5yYXdCb2R5KSB7XG4gICAgICBkZWJ1ZygnUGFyc2luZyByZXF1ZXN0IHdpdGggYSByYXdCb2R5IGF0dHJpYnV0ZScpO1xuICAgICAgcGFyc2VSYXdCb2R5ID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgcmVzb2x2ZShyZXEucmF3Qm9keSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ1BhcnNpbmcgcmF3IHJlcXVlc3QnKTtcbiAgICAgIHBhcnNlUmF3Qm9keSA9IGdldFJhd0JvZHkocmVxKTtcbiAgICB9XG5cbiAgICBwYXJzZVJhd0JvZHlcbiAgICAgIC50aGVuKChyKSA9PiB7XG4gICAgICAgIGNvbnN0IHJhd0JvZHkgPSByLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh2ZXJpZnlSZXF1ZXN0U2lnbmF0dXJlKHtcbiAgICAgICAgICBzaWduaW5nU2VjcmV0OiBhZGFwdGVyLnNpZ25pbmdTZWNyZXQsXG4gICAgICAgICAgcmVxdWVzdFNpZ25hdHVyZTogcmVxLmhlYWRlcnNbJ3gtc2xhY2stc2lnbmF0dXJlJ10sXG4gICAgICAgICAgcmVxdWVzdFRpbWVzdGFtcDogcmVxLmhlYWRlcnNbJ3gtc2xhY2stcmVxdWVzdC10aW1lc3RhbXAnXSxcbiAgICAgICAgICBib2R5OiByYXdCb2R5LFxuICAgICAgICB9KSkge1xuICAgICAgICAgIC8vIFJlcXVlc3Qgc2lnbmF0dXJlIGlzIHZlcmlmaWVkXG4gICAgICAgICAgLy8gUGFyc2UgcmF3IGJvZHlcbiAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5wYXJzZShyYXdCb2R5KTtcblxuICAgICAgICAgIC8vIEhhbmRsZSBVUkwgdmVyaWZpY2F0aW9uIGNoYWxsZW5nZVxuICAgICAgICAgIGlmIChib2R5LnR5cGUgPT09ICd1cmxfdmVyaWZpY2F0aW9uJykge1xuICAgICAgICAgICAgZGVidWcoJ2hhbmRsaW5nIHVybCB2ZXJpZmljYXRpb24nKTtcbiAgICAgICAgICAgIHJlc3BvbmQobnVsbCwgeyBjb250ZW50OiBib2R5LmNoYWxsZW5nZSB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBlbWl0QXJndW1lbnRzID0gW2JvZHkuZXZlbnRdO1xuICAgICAgICAgIGlmIChhZGFwdGVyLmluY2x1ZGVCb2R5KSB7XG4gICAgICAgICAgICBlbWl0QXJndW1lbnRzLnB1c2goYm9keSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhZGFwdGVyLmluY2x1ZGVIZWFkZXJzKSB7XG4gICAgICAgICAgICBlbWl0QXJndW1lbnRzLnB1c2gocmVxLmhlYWRlcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYWRhcHRlci53YWl0Rm9yUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGVtaXRBcmd1bWVudHMucHVzaChyZXNwb25kKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzcG9uZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlYnVnKCdlbWl0dGluZyBldmVudCAtICB0eXBlOiAlcywgYXJndW1lbnRzOiAlbycsIGJvZHkuZXZlbnQudHlwZSwgZW1pdEFyZ3VtZW50cyk7XG4gICAgICAgICAgYWRhcHRlci5lbWl0KGJvZHkuZXZlbnQudHlwZSwgLi4uZW1pdEFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICBoYW5kbGVFcnJvcihlcnJvciwgcmVzcG9uZCk7XG4gICAgICB9KTtcbiAgfTtcbn1cbiJdfQ==
//# sourceMappingURL=http-handler.js.map